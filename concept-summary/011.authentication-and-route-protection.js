/*

    Authentication Basics
    When building SPAs using Angular, we implement a flow where once a user from the client side has been
    authenticated(after login), the server sends the user a token, a JSON Web token(JWT) typically. It is a string
    that is encoded(not encrypted). This token is generated on the server with a certain algorithm and a certain
    secret which only the server knows and only the server can validate. Then our Angular App, stores that token in
    the local storage of the browser and thereafter attaches the token to any request that it sends to the server
    which needs to be authenticated. The server then validates each request by checking if the token is the same
    one and valid(one which the server created initially).


    Steps to introduce Authentication in your Angular app
    We first need to create a signup/login page that takes in a email id and password. The same page will be used for
    both sign up and login. We then create a route for authentication and add this component to the route. Then, in
    our backend we will enable authentication. For this, on Firebase, go to real time databases -> rules and then
    change the rules to this:
    { "rules": {
            ".read": "auth != null",  // 2022-12-29
            ".write": "auth != null",  // 2022-12-29
    }} <- this denies access to database unless user is authenticated
    Then you go to the authentication module in Firebase and enable email&password sign-in method. You can
    pick and choose any mechanism you want. For this we are adding email & password.
    Then we start creating users. For this we will use the UI that we created and start sending requests for user
    creation to the Firebase server.


    Creating an auth Service
    We will now create an auth service that has a sign up method which our auth component will make use of.
    We get the url for signup from the Firebase docs. We need to add the api key as a query param to this. We
    can find this key in the Project settings of our app on Firebase.
    interface AuthResponseData {
        idToken: string; email:	string; refreshToken: string; expiresIn: string; localId: string;
    }
    @Injectable({ providedIn: 'root' })
    export class AuthService {
        constructor(private http: HttpClient) {}
        signup(email: string, password: string) {
            const url = 'https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyCNAAcJRbb69wtlRtX_qb9SGB2W5Hi3rCo';
            return this.http.post<AuthResponseData>(url, { email, password, returnSecureToken: true });
        }
    }


    Sending the request
    We will now send the request when the user clicks on the signup form.
    onSubmit(authForm: NgForm) {
        if (!authForm.valid) return;
        if (this.isLoginMode) { // implement later }
        else {
            const email = authForm.value.email;
            const password = authForm.value.password;
            this.authService.signup(email, password)
                .subscribe(
                    responseData => { console.log(responseData); },
                    error => { console.log(error); });
        }
        authForm.reset();
    }


    Adding loading spinner and error handling
    Now we will add a loading spinner to the app when a request is made. We will also add error handling.
    For the loader we will get a spinner from loading.io/css website and create a component out of it with no ts logic
    @Component({
        selector: 'app-loading-spinner',
        template: '<div class="lds-hourglass"></div>',
        styleUrls: ['./loading-spinner.component.css']
    })
    export class LoadingSpinnerComponent {}
    We will ngIf this before a request is sent using an isLoading variable in the Auth component.
    Similarly we will add an error property to the auth component which will display the error message when there is one
    error: string = null;
    In the error handler of the subscribe method
    this.error = 'An error occurred';
    In the auth.component.html
    <div *ngIf="error" class="alert alert-danger"> {{ error }} </div>


    Meaningful Error messages
    We will add a more generic error handling approach which shows a more meaningful error message to the user
    based on the error message generated by the server.
    We will add use a pipe and then the rxJs operators catchError and throwError for this purpose
    signup(email: string, password: string) {
    return this.http.post<AuthResponseData>(url, {data})
      .pipe(
        catchError(errorRes => {
          let errorMessage = 'An unknown error occurred';
          if (!errorRes.error || !errorRes.error.error) {
            return throwError(errorMessage);
          }
          switch (errorRes.error.error.message) {
            case 'EMAIL_EXISTS':
              errorMessage = 'This email already exists';
          }
          return throwError(errorMessage);
        })
      );
    }


    Adding Login
    We will now introduce the login for the user
    login(email: string, password: string) {
        const url = 'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyCNAAcJRbb69wtlRtX_qb9SGB2W5Hi3rCo';
        return this.http.post<AuthResponseData>(url, {
            email,
            password,
            returnSecureToken: true
        });
    }


    Error handling for login
    We will use a common method to handle errors on signup and login since they behave in a similar manner and output
    error messages in the error object which we can use to run a switch case on, to identify/display the correct error
    message.
    private handleError(errorRes: HttpErrorResponse) {
        let errorMessage = 'An unknown error occurred';
        if (!errorRes.error || !errorRes.error.error) {
            return throwError(errorMessage);
        }
        switch (errorRes.error.error.message) {
            case 'EMAIL_EXISTS':
                errorMessage = 'This email already exists'; break;
            case 'EMAIL_NOT_FOUND':
                errorMessage = 'This email does not exist'; break;
            case 'INVALID_PASSWORD':
                errorMessage = 'This password is not correct'; break;
        }
        return throwError(errorMessage);
    }
    We then pipe the catchError to both signup and login
    return this.http.post<AuthResponseData>(loginUrl, body).pipe(catchError(this.handleError));
    return this.http.post<AuthResponseData>(signUpUrl, body).pipe(catchError(this.handleError));


    Creating and storing user data
    We will store and use user data for maintaining state in the application.
    We will first create a user model
    export class User {
        constructor(public email: string, public id: string, private _token: string, private _tokenExpirationDate: Date) {}
        get token() {
            if (!this._tokenExpirationDate || new Date() > this._tokenExpirationDate) {
              return null;
            }
            return this._token;
        }
    }
    To the auth service we add a user Subject which will hold the logged in user object and will be used as the object
    to check if authentication is valid or not in the application
    In the auth service
    user = new Subject<User>();
    login(email: string, password: string) {
        const url = 'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyCNAAcJRbb69wtlRtX_qb9SGB2W5Hi3rCo';
        return this.http.post<AuthResponseData>(url, { email, password, returnSecureToken: true })
            .pipe(
                catchError(this.handleError),
                tap((responseData) => {
                  this.handleAuthentication(responseData.email, responseData.localId, responseData.idToken, responseData.expiresIn);
                })
            );
    }
    private handleAuthentication(email: string, localId: string, idToken: string, expiresIn: string) {
        const expirationDate = new Date(new Date().getTime() + (+expiresIn * 1000));
        const user = new User( email, localId, idToken, expirationDate );
        this.user.next(user);
    }



    Reflecting the auth state in the UI
    Once the login is successful, we will navigate the user away from the authentication page to the recipes page.
    authObservable.subscribe(responseData => { this.router.navigate(['/recipes']); });
    Then, we will mark the user as logged in and send this information forward using the subject. Any component
    (like the header) interested in knowing the current status of the user can subscribe to the subject and make
    changes in the template accordingly.
    In header.component.ts
    ngOnInit() {
        this.userSubscription = this.authService.user.subscribe(user => { this.isAuthenticated = !!user; });
    }
    Based on the this.isAuthenticated variable we can show the user different links in the navbar and also a logout
    button when the user is logged in.




 */